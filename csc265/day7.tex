\section{Day 7: B-Trees (Sep 22, 2025)}

Today is the last day of balancing trees. Next class, we will study randomization and hashing, so make sure to brush up on probability.

A \textbf{B-tree} is a balanced tree with a large `branching factor', meant to be a generalization of a BST. Every node has a lot of children, and that each node stores a lot of keys. Beefier nodes means you traverse to the lower nodes less frequently, which generally translates to faster times: a useful property for secondary storage.

\begin{definition}[B-Tree]
    B-Trees have the following properties
\begin{enumerate}
    \item Every non-root node contains $t - 1 \leq n(x) \leq 2t - 1$ keys. The root node contains at most $2t - 1$ keys, but can have as few as 1 key. $t \geq 2$ is the minimum degree.
    \item Every node has $n(x) + 1$ children (thus between $t$ and $2t$ children), being $c_1, \cdots, c_{n(x)+1}$.
    \item Every leaf has the same depth.
\end{enumerate}
\end{definition}

Note that this works best where $t$ is quite large. 

\begin{simplethm}
If $n \geq 1$, a B-tree with $n$ keys and min degree $t$ has height $h \leq \log_t (\frac{n+1}{2})$.
\end{simplethm}
\begin{proof}
    The root node has at least 1 key. The other nodes have at least $t - 1$ keys. At depth 0, there is 1 node, being the root node. The root node has $n(x) + 1 = 1 + 1 = 2$ children. At depth 2, each child has $2t$ children, and at depth $h$ it is $2t^{h-1}$.
    \[
    n \geq 1 + \sum_{i=1}^{h} (t-1)2t^{i-1} = 2t^h-1
    \]
    Thus $h \leq \log_t (\frac{n+1}{2})$.
\end{proof}

\begin{description}
    \item[Search($T$, $k$)]: First use linear search to find $k$ in node $x$, and return if found. \\
    Else find the successor\footnote{in-order successor?} $k_i$ of $k$, and search the subtree rooted at $c_i$. If $k$ is larger than all key, search $c_{h(x) + 1}$.
    \item[Insert($T$, $k$)]: Search for the leaf node to insert $k$. If it has less than $2t - 1$ keys, the insert is easy and we are done. If the current node $x$ has $2t$ keys after $k$ is added, we need to split the overflowing node as follows:

    Let $k'$ be the median (key at rank $t$). Create 2 new nodes, one with $t-1$ keys less than $k'$, and one with $t$ keys greater than or equal to $k'$. Recursively insert $k'$ to the parent as the new divider between the 2 new nodes. If there is no new parent, then create new root with key $k'$ and 2 children. 

    \item[Delete($T$, $k$)]: Maintain that the node we enter has at least $t$ keys (unless it's the root). We must handle a lot of cases:
    \begin{enumerate}
    \item If $x$ is a leaf, then remove $k$ from $x$ if it exists.
        \item If $x$ is an internal node with key $k_i$: \\
        a) If child $y$ that precedes $k$ in $x$ has at least $t$ keys. Let $k'$ be the largest key in the rightmost leaf of $y$. Recursively delete $k'$ from $y$, replace $k$ with $k'$ in $x$. We don't need to know what $k'$ is to perform this recursive call. \\
        b) If child $z$ that follows $k$, then it is symmetric
        c) In the case where both $y$ and $z$ have $t-1$ keys, then TODO
        \item If $x$ is an internal node and $k$ not in $x$, let $c_i$ be the next node to visit. If $c_i$ has $t-1$ nodes,  
    \end{enumerate}
\end{description}
