\section{Day 6: AVL Trees and Augmenting Data Structures (Sep 17, 2025)}

We start with some administrative details. ``You guys definitely need some feedback before the next assignment. Half of you write good, the other half - not so good. Well the first assignment is always a bit rough anyways. Usually when Faith teaches this class, the average is a 50\%-60\% ''. A2 official solutions are around 6-7 pages, so the page limit shouldn't be an issue. New office hours dropping Friday 4 to 5pm.

We continue with AVL trees. Desired properties of rotations while using \textsc{Insert} include: constant step count, preserve the BST property, fix the imbalance at the node.  Let $m$ denote the first node where the balance factor becomes unacceptable. The rotation should preserve the height of the subtree located at $m$ before insertion and after rotation. 

For AVL trees, each node $x$ stores: $key$, $left$, $right$, $BF$ (balance factor), and $parent$. \textbf{If inserting a node does not alter the height of a subtree, then it wouldn't have caused an imbalance}.

\begin{description}
    \item[Delete($T$, $z$)] Begin with standard BST delete, reduces to removing a leaf node. Do cases on a node $z$. If $z$ is a leaf, we are done. If $z$ has 1 child, the other child must be \textsc{Nil}, by height-balanced property replace $z$ with $y$. From the leaf to root, you would need to update the balance factors and do rotations as necessary. If $z$ has 2 children, replace $z$ with its successor which goes back to case 0 or 1 child. 
\end{description}

\begin{simplethm} \label{thm:avldelinsertrcount}
\textsc{Delete}($T$, $z$) may perform up to $O(\log_2 n)$ rotations, while \textsc{Insert}($T$, $z$) does at most 1. 
\end{simplethm}

\subsection{Augmenting Data Structures}

We want to augment existing data structures with new information to implement new operations.

\subsection*{InOrderTraversal($T$)}
\begin{algorithmic}[1]
    \State \textsc{InOrderTraversal}($T.left$)
    \State Print $T.key$
    \State \textsc{InOrderTraversal}($T.right$)
\end{algorithmic}

An order statistic tree is an augment AVL tree supporting the new operations
\begin{description}
    \item[OS-Select($T$, $i$)]: returns pointer to the $i$-th smallest element, according to the in-order Traversal
    \item[OS-Rank($T$, $x$)]: given pointer to $x \in T$, returns the position of $x$ to the in-order traversal
\end{description}
We can't have nodes store the rank, because this would require linear time updates when you insert a new smallest key. Instead we store $size$, that is the number of nodes in the subtree rooted at $x$. 

Now we need to modify \textsc{Insert}/\textsc{Delete}. Suppose $x.left$ and $x.right$ are properly updated. To be careful, we define $\textsc{Nil}.size = 0$, then compute $x.size = x.right.size + x.left.size + 1$. Also remember to update the size field during a rotation.

We are lucky that we can do updates to $size$  from top-down during an insert. For other statistics, we aren't so lucky, e.g. $sum$. Typically we do it from bottom to top, because that way it always works.

\subsection*{OS-Select($x$, $i$)}
\begin{algorithmic}[1]
    \State r = $x.left.size$ + 1 
    \If{$r = i$}
    \State return $x$
    \ElsIf{$i < r$}
    \State return \textsc{OS-Select}($x.left$, $i$)
    \ElsIf{$i > r$}
    \State return \textsc{OS-Select}($x.right, i - r$)
    \EndIf
\end{algorithmic}


